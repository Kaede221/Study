/* 内存分区模型
C++在执行的时候, 内存会大致被分为四个区域
代码区: 存放函数和二进制代码的区域, 由操作系统进行管理
全局区: 存放全局变量, 静态变量以及常量
栈区: 由编译器自动分配释放, 存放局部变量, 函数参数
堆区: 由程序员分配和释放, 如果程序员不释放, 那么会在程序结束的时候释放
*/

/* 存在的意义
不同区域储存不同内容, 有不同的生命周期, 有更加灵活的编程
*/

/* 程序运行前
代码区:
	存放CPU执行的机器指令
	代码区是共享的, 目的是可以让需要频繁被执行的程序, 可以更快的启动, 因为内存中只需要有一份代码
	代码区是只读的, 是为了防止其他程序篡改指令

全局区:
	全局变量和静态变量存储在这里
	全局区还有常量区, 字符串常量和其他常量也在这里
	该区域的数据在程序结束后由操作系统释放
*/

/* 程序运行后
栈区:
	由编译器自动分配释放, 存放参数, 局部变量
	注意, 不要返回局部变量的地址, 否则可能会非法访问一个已经释放的内存
堆区:
	程序员手动创建, 消除的内容, 你可以使用new关键字来开辟数据
*/
#include <iostream>
using namespace std;

//在外面定义的就是全局变量了
int gA = 10;
int gB = 10;

//const可以修饰全局变量
const int const_global_A = 10;
const int const_global_B = 10;

int* func() {
	//我们可以试试返回一个局部变量的地址
	int a = 10;
	//这个局部变量储存在栈区, 所以一旦退出函数, 就会被释放, 从而无法访问里面的内容
	return &a;
}

int* func2(){
	//用这个函数, 可以在堆区开辟一个新的变量
	//new 类型(初始值)
	//直接返回的就是一个地址, 你可以通过指针来获取
	return new int(20);
}

int main() {
	//普通的局部变量
	//只要在函数体(main函数也算)里面定义的变量, 就是一个临时的数据
	int a = 10;
	int b = 10;
	//你可以看到, 这两个数据的地址还是比较近的
	cout << "a 地址为: " << (int)&a << endl;
	cout << "b 地址为: " << (int)&b << endl;
	//相比上面这个, 你就会发现地址比较远了 因为储存在不同的区域里面
	cout << "ga 地址为: " << (int)&gA << endl;
	cout << "gb 地址为: " << (int)&gB << endl;

	//静态变量的话, 就是const
	const int sA = 10;
	const int sB = 10;
	//你会发现, 地址又不一样了 但是和局部变量放的比较近
	cout << "sa 地址为: " << (int)&sA << endl;
	cout << "sb 地址为: " << (int)&sB << endl;

	//还有字符串常量 就是双引号的内容
	//你会发现, 和全局变量放的很近
	cout << "字符串常量地址: " << (int)&"Hello World" << endl;

	//全局常量的地址
	//你会发现, 和其他常量都差不多在一块
	cout << "全局常量A地址: " << (int)&const_global_A << endl;
	cout << "全局常量B地址: " << (int)&const_global_B << endl;

	//反正, 只要是局部修饰的, 那么基本上都在一个地方, 全局的都在一个地方

	//试一试使用局部变量的地址
	int* p = func();
	//你发现, 居然成功了?
	cout << *p << endl;
	//但是你再试一次? 如果成功了, 那么说明你的电脑不错, 因为编译器为你做了保留, 但是不是永久的, 后面可能就会变了
	//一般, 32位系统只能用一次, 但是64位系统可以用很多次
	cout << *p << endl;

	//堆区的话, 你可以使用一个新的关键字: new
	p = func2();
	cout << *p << endl;
	return 0;
}

